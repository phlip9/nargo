#![allow(dead_code)] // TODO(phlip9): remove

use std::str;

/// parsed build_script_build output
#[cfg_attr(test, derive(Debug, PartialEq, Eq))]
pub struct BuildOutput<'a> {
    // TODO
    // /// Paths to pass to rustc with the `-L` flag.
    // pub library_paths: Vec<&'a Path>,
    // /// Names and link kinds of libraries, suitable for the `-l` flag.
    // pub library_links: Vec<String>,
    // /// Linker arguments suitable to be passed to `-C link-arg=<args>`
    // pub linker_args: Vec<(LinkArgTarget, String)>,
    //
    /// Various `--cfg` flags to pass to the compiler.
    pub cfgs: Vec<&'a str>,
    /// Various `--check-cfg` flags to pass to the compiler.
    pub check_cfgs: Vec<&'a str>,
    /// Additional environment variables to run the compiler with.
    pub env: Vec<(&'a str, &'a str)>,
    //
    // TODO
    // /// Metadata to pass to the immediate dependencies.
    // pub metadata: Vec<(String, String)>,
    // /// Errors and warnings generated by this build.
    // ///
    // /// These are only displayed if this is a "local" package, `-vv` is used, or
    // /// there is a build error for any target in this package. Note that any log
    // /// message of severity `Error` will by itself cause a build error, and will
    // /// cause all log messages to be displayed.
    // pub log_messages: Vec<LogMessage>,

    // NOTE(phlip9): rerun_if_changed and rerun_if_env_changed are intentionally
    // left out, as they are pointless in pure nix builds.
}

//
// --- impl BuildOutput ---
//

impl<'a> BuildOutput<'a> {
    fn parse(input: &'a [u8]) -> Self {
        let mut out = Self {
            check_cfgs: Vec::new(),
            cfgs: Vec::new(),
            env: Vec::new(),
        };

        for line in input.split(|b| *b == b'\n') {
            let line = match str::from_utf8(line).ok() {
                Some(line) => line.trim(),
                None => continue,
            };

            let _ = out.parse_directive(line);
        }

        out
    }

    fn parse_directive(&mut self, line: &'a str) -> Option<()> {
        let line = line.strip_prefix("cargo:")?;
        // TODO(phlip9): parse old format cargo:<metadata>=<value>
        let line = match line.strip_prefix(':') {
            Some(x) => x,
            None => line,
        };

        let (key, value) = line.split_once('=')?;

        match key {
            // TODO(phlip9): parse the other flags ofc
            "rustc-cfg" => self.cfgs.push(value),
            "rustc-check-cfg" => self.check_cfgs.push(value),
            "rustc-env" => {
                let (env_key, env_value) = value.split_once('=')?;
                self.env.push((env_key, env_value));
            }
            _ => return None,
        }

        Some(())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse() {
        let anyhow_1_0_86 = r#"cargo:rerun-if-changed=build/probe.rs
cargo:rerun-if-env-changed=RUSTC_BOOTSTRAP
cargo:rustc-check-cfg=cfg(anyhow_nightly_testing)
cargo:rustc-check-cfg=cfg(anyhow_no_fmt_arguments_as_str)
cargo:rustc-check-cfg=cfg(anyhow_no_ptr_addr_of)
cargo:rustc-check-cfg=cfg(anyhow_no_unsafe_op_in_unsafe_fn_lint)
cargo:rustc-check-cfg=cfg(doc_cfg)
cargo:rustc-check-cfg=cfg(error_generic_member_access)
cargo:rustc-check-cfg=cfg(std_backtrace)
cargo:rustc-cfg=std_backtrace
"#;
        let actual = BuildOutput::parse(anyhow_1_0_86.as_bytes());
        let expected = BuildOutput {
            cfgs: vec!["std_backtrace"],
            check_cfgs: vec![
                "cfg(anyhow_nightly_testing)",
                "cfg(anyhow_no_fmt_arguments_as_str)",
                "cfg(anyhow_no_ptr_addr_of)",
                "cfg(anyhow_no_unsafe_op_in_unsafe_fn_lint)",
                "cfg(doc_cfg)",
                "cfg(error_generic_member_access)",
                "cfg(std_backtrace)",
            ],
            env: vec![],
        };
        assert_eq!(actual, expected);

        let anyhow_1_0_86_new = anyhow_1_0_86.replace("cargo:", "cargo::");
        let actual = BuildOutput::parse(anyhow_1_0_86_new.as_bytes());
        assert_eq!(actual, expected);
    }
}
